## 11월24일 
* 실무 개발자(초보개발자)가 가져야할 기본기술
1. 화면제어 : HTML, CSS , Javascript + Bootstrap, Jquery
2. 데이터 제어 : SQL, JDBC, API, Mybatis 프레임 워크
3. 언어 및 도구 : Java, VScode, Eclipse, Git, Gradle(빌드도구)
  


시스템 소프트웨어 : 하드웨어 제어 목적. But 태블릿같은 하드웨어를 제어할 수 있는 소프트웨어가 벼로돌 없기에 Driver와 같은 소프트웨어를 제작.

        ex)  OS(운영체제) , Driver, TCP/IP,  DirectX

응용 소프트웨어(Application s/w) : 응용프로그램을 의미

        ex)  HWP, PPT, Web browser, 게임 등

    
  *  standalone(단독으로 실행 가능) : 로컬(Local)에 설치하면 단독으로 사용가능함

        ex) HWP, Photo Shop, 그림판, 메모장, MSoffice
  * Client / Server(CS : 양방향으로만 가능) : 로컬과 원격에 동시에 설치해야 함
        (서버없으면 동작할 수 없음)
        ex) 게임, 메신저, E-mail, 

    * Client /Server는 설치형, 서비스형으로 나뉜다. 설치형은 게임, 메신저 등(업데이트 필요)이 있으며 서비스형에는 E-mail 등(업데이트 필요 X)이 있다.

        * 서비스형 Application은 client가  server에 요청하면 server에서 작업이 이루어지고 client에게 응답하는 구조이다. client s/w가 사용자에게 입력받고 작업결과 출력.
        server s/w는 요청작업을 처리.
        모든 작업이 server쪽에서 실행된다.
        server는 여러 client의 요청을 처리한다.(Hardware의 성능이 좋아야함 -> 분산 computing의 등장. 한대의 컴퓨터가 아니라 여러대의 컴퓨터에서 server를 담당.)

        Web Application
        
        web server:  실행 ------>  <-------결과리턴  :App

        Java App에서 DBMS로  연결하는 과정은 Mybatis 프레임워크 이용.
        화면 출력은 HTML(contents),CSS(Contents의 모양) Javascript (Contents의 동작 제어)이용.
        
 ----------           



## 11월 25일
 ----------------------------------------------------------------------
 * Git Repo에 백업된 파일+ 변경기록을 복제해 오는 것이 clone 명령어.

      $User_HOME  = C:\Users\jys76\

    ex) Repo에 백업된 파일 bitcamp-study ->를
    C:\Users\jys76\에 클론 ->C:\Users\jys76\git\bitcamp-study(작업디렉토리)\.git(설정관련 파일: 백업된 파일을 편집할 수 있도록 꺼낸다. 백업 디렉토리의 역할) 
    작업할 파일을 꺼내오는 것을 check out. 작업디렉토리에서 백업디렉토리로 넘기는 작업을 commit이라고 한다.
  
  < local Repo >

  hello.txt ->변경
  
  README.md                  

  Hello.txt ->추가

 => Stage(백업명단)에 add => Stage에 등록된 파일을 
                                 Local Repo에 commit => Push를 통해 로컬저장소의 내용을 Server Repo에 Upload.

  때문에 Local 저장소에 파일을 백업하는 commit작업은 네트워크에 연결이 되어있지 않아도 수행 가능하다.

  pull 명령어 : 서버의 변경 사항을 내 local로 당겨오는 것.
  merge 명령어 : 서버의 변경사항과 local의 변경사항을 합치는 것

  * git으로 수업 준비 : 강사의 server Repo에서 pull 로 당겨서 보기만하기. pull로 당긴 파일을 편집하면 충돌이 일어남.
  * .gitignore : .으로 시작하는 무시하라는 설정파일


------------------------------------------------------------------------
  ## Application 빌드와 실행
  
  >1.인터프리터 방식 : Javascript 등
    자바스크립트 개발자 -> Javascript파일에서 명령문 실행 -> V8(Javascript 인터프리터). 크롬안에 webkit(HTML, CSS처리), V8(Javascript 처리)하는 툴이 있다. 
    Runtime 이전에 기계어로 해석하는 컴파일 방식과 다르게 Runtime이후에 해석하는 방식.
  **장점**
    - 인터프리터가 설치되어 있다면 OS와 CPU에 상관없이 실행 가능.
  **단점** 
    - 실행하기위해서는 소스파일이 있어야하고, 인터프리터가 설치되어 있어야 한다. 
    - 실행할 때마다 문법검사를 실행한다. 
    - 컴파일방식에 비해 실행속도가 느리다
    
  
  >2.컴파일 방식 : C, C++ 등
    개발자 -> 명령문 -> 번역기(computer) -> 번역과정을 거쳐 기계어(실행파일) 실행 -> OS에서 동작. 
    프로그래밍 언어를 Runtime 이전에 기계어로 해석하기 때문에 구동시간이 오래걸린다. 하지만 구동이후에는 하나의 패키지로 매우 빠르게 작동한다.
  **장점**
     - 인터프리터 방식보다 실행속도가 빠르다.
     - OS나 CPU에 맞는 실행파일만 있으면 실행 가능. 
     - 소스와 컴파일러가 필요없다.  
  **단점** 
     - OS나 CPU가 다르면 실행불가.
 
   
    ex) 안드로이드 모바일의 app을 애플 모바일에서 사용할 수 없다.
   >3.하이브리드 방식 : Java : 등
    [명령문 -> 컴파일러가 번역 -> 가상기계여(중간코드)] : 개발자의 역할(OS,CPU에 상관없이 프로그래밍 및 컴파일 가능)->인터프리터가 실행(JVM) ->OS ->CPU에서 실행
    시스템 관리자가 해당 OS/CPU에 맞는 인터프리터 설치.
    인터프리터 방식과 비교  : 컴파일 할 때 문법검사 완료(어느정도 기계어에 가깝게 변경->인터프리터방식보다 비교적 빠르다. )
    컴파일 방식과 비교 : 
      
  |인터프리터 방식|컴파일방식|하이브리드 방식<br>(컴파일+인터프리터)|
  |:--:|:--:|:--:|
  |실행하기 위해소스파일 필요  | 실행파일만 있으면 실행가능||
  |컴파일러 필요 |컴파일러 불필요|
  |컴파일방식에 비해 속도 느림 |인터프리터방식에 비해 속도빠름|
  |인터프리터 설치시 OS, CPU상관 없이 실행가능 |OS,CPU다르면 실행 불가능 |

    

  - 기계어 코드와 OS/CPU
  > 1. CPU 마다 명령어가 다르다
    Intel CPU는 Intel CPU가 이해할 수 있는 명령어로 작성되어야 실행할 수 있다.
    ex) Intel과 AMD는 명령어가 서로 호환되기 때문에 CPU가 달라도 프로그램을 따로 변환하지 않아도 그대로 실행 가능.
    서로 호환이 되지 않는다면 전용 프로그램을 따로 만들어서 변환해야 한다.

  - 같은 CPU더라도 OS가 다르다면(windows, Linux) 같은 App을 사용 할 수 없다. 
  >ex ) 같은 이력서를 window(삼성) , Linux(LG)에 제출했다. 삼성과 LG는 모두 한국어를 사용한다(같은 CPU언어). 하지만 삼성은 합격했지만 LG는 떨어졌다. 각 회사가 요구하는 이력서 양식이 다르기 때문이다.
  그래서 각 OS가 요구하는 포맷에 맞춰 명령어를 사용해야 한다.
  CUP가 같다는 것은 사용하는 명령어가 같다는 의미이다. 하지만 각 OS에 맞는 기계어(실행파일)를 사용해야 한다.


---
# 11월 26일
  - JVM / JRE / JDK / Java SE / Java ME
>Java 분류

|Java SE(Standard Edition|Java App 기본도구|
|:--:|:--:|
|JDK(Java Development Kit| JRE + 개발도구(컴파일러 , 디버거, 프로파일러|
|JRE(Java Runtime Environment|JAVA App 실행도구|
|JVM(Java Virtual Machine|Byte code interpreter|
|Java EE(Enterprise Edition|기업용 App 개발 관련 도구 *Java SE를 포함하지않는다. Jakarta EE로  이름변경됨(개발관리 소유권이 Eclipse 재단에 넘어감|
|Java ME(Micro Edition)|Embedded App 개발도구(반도체 메모리에 Java App미리 저장|

- Java 컴파일과 실행

>Hello.java -> 컴파일(javac.exe) -> Hello.class(Byte code : 가상의 기계어) -> 실행 불가능. 진짜 기계어가 아니기 때문. 그래서 JVM이 필요

>Hello.class -> JVM -> OS
 ex ) 
  
  |Class역할|JVM역할|
  |:--:|:--:|
  |.ppt |파워포인트| 
  |.xls |엑셀|
  |.mp3  |플레이어|    

  - Java 언어로 명령문 작성하는 최소 코드
      class Hello(클래스 명){

        public static void main(메서드 명 : JVM이 명령문을 시작하는 입구(String[] args){
          
        }
      } 

||Text 파일|Binary 파일|
|:--:|:--:|:--:|
|저장 형식|UTF -8 등 특정 문자 집합의 규칙에 따라 저장|.ppt, .pdf, .gif 등 특정 어플리케이션의 포맷에 맞춰 저장|
|파일보기| 텍스트 편집기라면 파일보기가능|해당 파일의 포맷의 알고있는 프로그램만가능|
|파일편집|텍스트 편집기는 모두가능|해당 파일의 포맷을 지원하는 프로그램가능(전용프로그램 필요)|
|파일크기|파일크기가 크다|크기가 작다|
|ex|.csv , .xml , .html, .cs , .js등|.pdf , .jpg, .png, .mp3 등|

- 프로그램 명령문(코드) 관리
    - 단순관리
    - 기능별로 묶어서 관리(코드가 복잡해지고 많아졌기 때문에)
    - 서로 관련된 기능을 "분류(Class)"하여 묶어서 관리  
    ex)
      > class calculator{
      }
       > class Math{
      }
       >class String{
      }

**클래스를 지정할 때 반드시 패키지명을 지정해야 한다**
### 11월26일 질문
- Java 최소 코드를 작성할 수 있는가?
  - 앤트리 포인트(entry point)의미를 설명할 수 있는가?
- Java 컴파일러를 사용하여 자바 소스를 컴파일 할 수 있는가?
  - 소스 파일과 클래스 파일을 분리하여 컴파일 할 수 있는가?
- JVM을 사용하여 Java 클래스 파일을 실행할 수 있는가?
  - 패키지에 소속된 클래스 파일을 실행할 수 있는가?
- 텍스트 파일과 바이너리 파일을 구분하는 방법을 아는가?
- 함수와 클래스, 패키지 문법이 등장한 이유를 설명할 수 있는가? 
  = 방대한 양의 코드를 체계적으로 관리하기 위하여.
- Java가 C/C++ 언어와 달리 각 파일마다 컴파일 하는 이유를 설명할 수 있는가?
- Java에서 편집한 소스 파일을 한 번에 컴파일하는 수동 컴파일 방식 보다 각 소스 파일 별로 자동으로 컴파일 하는 방식을 사용하는 이유를 설명할 수 있는가?(C/C++사례와 비교 설명)
- 이클립스 IDE용 프로젝트 폴더 구조와 Maven 프로젝트 폴더구조의 차이점을 설명할 수 있는가?
- 빌드 도구의 역할을 설명할 수 있는가? 
  - Ant, Maven, Gradle 빌드 도구를 비교 설명할 수 있는가?
- gradle 빌드 도구를 설치하고 설정할 수 있는가?
- gradle을 이용하여 자바 프로젝트 폴더를 구성할 수 있는가?
- build.gradle 빌드 스크립트 파일에 이클립스 관련 설정을 수행할 수 있는가?

  |자동컴파일|수동컴파일|
  |:--:|:--:|
  |Java IDE  도구에서 보통 자동컴파일을 수행한다|C/C++과 같은 기존 프로그래밍 언어에서 수동컴파일을 수행|
  
    App.c -> 컴파일 -> App.obj생성
    Sbu1.c-> 컴파일 -> Sub1.obj생성

    =>결과적으로 App.exe을 생성(링킹 작업)
 
  C/C++은 한개의 실행 파일을 만들기 때문에 보통 여러 파일의 코드를 변경한 후 한번에 컴파일 한다. 

 
  Java는 소스 파일을 변경할 때 각 파일마다 컴파일 한다. 또한 실행파일을 만들지 않는다. 
 
  ## 프로젝트 폴더의 기본 구조
  - 프로젝트폴더 -> 이클립스 IDE에서 사용하는 프로젝트 폴더구조(다른 IDE 툴과 호환이 안됨.)
    - src / : 자바소스파일, 설정파일
    - bin / : 컴파일된 클래스파일
    - {.project : 프로젝트 정보
    - .classpath : 외부 개발자가 제공하는 클래스파일
    - . settings / : 에디터 설정정보}
      =>이클립스 전용파일    

- 빌드도구 : 프로젝트의 소스 컴파일, 테스트, 문서생성, 배포파일 생성 등 애플리케이션을 만드는 작업을 도와주는 도구다.(컴파일러, 인터프리터 개념이 아니다. 컴파일러나 인터프리터를 사용하여 애플리케이션을 만든다.) 
   1.Ant-예전프로젝트(build.xml : 설정파일-컴파일방법, 테스트방법, 디렉토리정보) + 외부 라이브러리 기능이 없기 때문에 외부라이브러리 관리 기능을 추가해준다.
   2. Maven(웹프로젝트 -pom.xml : 설정파일 ) + XML태그 대신 groovy나 kotlin 같은 프로그래밍 언어를 사용하여 빌드과정을 정교하게 제어할 수 있다. 
   3. Gradle(Android 앱 및 최신프로젝트 : Maven 빌드도구의 기능을 사용). Gradle을 사용한다면 build.gradle(groovy : 설정파일)
   
## Gradle을 이용하여 Maven 표준 프로젝트 디렉토리 생성하기
 1. 프로젝트 폴더로 사용할 디렉토리 생성 : ~/git/bitcamp-study/java-lang
 2. 프로젝트 폴더를 구성 : $gradle init
 3. 이클립스용 프로젝트 설정파일 생성

     
