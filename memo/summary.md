# Spring boot란
- 엔터프라이즈 어플리케이션 개발을 용이하게 해주는 Spring framework의 복잡한 초기 설정없이 바로 개발에 들어갈 수 있게 해주는 프레임워크이다. 
- Spring boot는 관련 라이브러리를 일일이 추가할 필요 없이 spring-boot-starter-web을 통해 손쉽게 받아올 수 있다. 

**framework** : framework는 library보다 상위 개념이다. 여러기능을 가진 클래스와 라이브러리가 특정 기능 구현을 위해 합쳐진 형태이다. 메소드 , 클래스, 모듈은 기능의 재사용성을 목적으로 하는데- framework는 재사용성을 목적으로 하는 요소들을 큰 단위로 묶어주는 역할을 한다. 

  * 스프링 부트 실행
  
 ![](./images/2021-12-03-00-38-30.png)

   * JVM(자바가상머신) : JAVA와 OS사이의 통로역할, JAVA소스를 OS에 구애받지 않고 재사용할 수 있도록 해줌.



### 리터럴(literal)(값을 표현한 것)


 - 리터럴은 소스 코드의 고정된 값을 대표하는 용어이다.
 ![](./images/2021-12-03-00-39-15.png)
 
 - 종류에는 정수, 실수, 문자, 논리, 문자열 리터럴이 있다. 
   - 정수 : 자연수(양의 정수), 자연수에 음의 부호를 붙인 음의 정수, 0을 합친 수의 모임.
     - 정수 type에는 byte,short(=2byte), int(=4byte), long(=8byte)가 있다.
   - 실수 : 직선상에 위치한 수들을 의미한다.
     - 실수 type에는 float(=4byte), double(=8byte)가 있다.
   - boolean : true or false(1byte)
   - 문자타입 : char(2byte)

  - 정수 리터럴과 진수법
    |10진수|100 = 10의2승 *1 +  10의1승 * 0 + 10의0승 * 0|
    |:--:|:--:|
    |8진수|100 = 0144-> (8의 2승 *1) +(8의 1승 *4) + (8의 0승 *4)|
    |2진수|100 = 01100100 ->(2의6승 * 1) +(2의 5승 * 1) + (2의 2승 * 1)
    | 16진수|100 = 0x64 -> (16의 1승 *6) + (16의 0승 * 4)|

   - 비트의 전기 상태를 표현하는 간단한 방법
     - 2진수 표기법
       -다양한 형태의 값을 메모리에 저장할 때 형태에따라 다른 규칙들이 필요하다.
       메모리에 저장하려면 2진수로 표현할 수 있어야 하기 때문이다.
   - 값(Data)과 2진수의 관계 

|--|--|
|--|--|
|숫자|2의 보수법|                           
|문자|charset|                            
|색|RGB|     

- 정수를 2진수로 변환하는규칙
   - sing magnitude(절대부호)
   +5 : 0101
   -5 : 1101
   0(양의 부호비트)
   1(음의 부호비트)
   -> 양수와 음수의 더하기가 불가능(양수와 음수를 더했을 때 실제 값과 다른 결과의 2진수로 표기됨) ->부동소수점에서 가수부를 저장할 때 사용

   - 1의 보수 (**보수 : 보충해주는 수**)
   
   2진수로 표현된 값의 반대 값 ex) 5 = 0101 ->1010 : 5의 1의보수
   
   -> 실제 결과 값에 1을 더해줘야 정확한 결과 값이 나온다.

   - 2의 보수
     - 2의 보수는 
       - 1. 7을 예로 들면 7을 이진수로 표현 -> 컴퓨터는 8비트를 사용 00000111
       - 2. 7에 대한 1의 보수를 구한다 -> 11111000
       - 3. 구한 1의 보수에 1을 더해준다 -> 11111001
       - 4. 7의 2진수 값(00000111) 과 1의 보수에 1을 더한 값(11111001) 을 더해 결과 값이 0이 되는지 확인한다.

   - excess-k규칙(초과법)
     - 4bit를 기준으로 하면, 4bit는 0~15까지 16개의 수를 나타낼 수 있다. 
       - ﻿1111 (15) ->  7

1110 (14) ->  6

1101 (13) ->  5

1100 (12) ->  4

1011 (11) ->  3

1010 (10) ->  2

1001 (9)  ->  1

1000 (8)  ->  0

0111 (7)  -> -1

0110 (6)  -> -2

0101 (5)  -> -3

0100 (4)  -> -4

0011 (3)  -> -5

0010 (2)  -> -6

0001 (1)  -> -7

0000 (0)  -> -8
  -> nbit 기준으로 -(2의n-1승) ~ +(2의 n-1승-1) : 4bit 일 때 -8(-2의4-1승) ~ 7(2의4-1승-1)까지 표현이 가능하다. 부동소수점에서 지수부를 저장할 때 사용.
  <br>
  - 부동소수점을 2진수로 변환하는 규칙
  <br>
     ![](./images/2021-12-03-00-42-33.png)
     <br>
     <br>
      - 10.625라는 소수를 예로들면
        - 1.우선 정수부와, 소수부를 분리하고 정수부를 2진수화 시킨다 -> 10 = 1010
        - 2. 소수부의 숫자가 0으로 나누어 떨어질 때까지 2를 곱해준다. -> 0.625 * 2 = 1.25
        - 3. 그 후 정수부를 2진수로 표기 한 후 다시 소수부에만 2를 곱한다 -> 1 x x x, 0.25 * 2 = 0.5
        - 4. 이런식으로 소수부가 0으로 나누어 떨어질 때까지 반복한다. -> 1 0 x x, 0.5 * 2 = 1.0
        - 5. 1 0 1. 최종적으로 소수부는 1 0 1 이 되었다.
        - 6. 정수부 소수부의 2진수표기를 합치면 10.625 = 1010.101로 표기된다.
    - 부동소수점을 메모리에 저장하는 법
      - 1. 부동소수점을 2진수로 변환한다 : 정수부분을 2진수로 표현. 소수부분은 0으로 나눠떨어질 때 까지 2를곱하여 2진수로 표현
      - 2. 정수,소수의 2진수를 합쳐 표기하여 제일 왼쪽의 1부분까지 소수점을 옮긴다.  ex) 111.011010 -> 1.11011010. 소수점을 옮긴 자리수만큼 카운트 하고 정수부분의 1을 버린다. (2번 옮겼으니 2의 2승) -> 정규화 과정
      - 3. 1을 버리고 남겨진 소수부분을 가수부 영역에 할당하고 총 비트수가 23비트가 되도록 0으로 채운다.
      - 4. 2번에서 소수점을 옮긴 자리수만큼의 수에 32비트의 bias값인 127을 더해준다 = 127+2 그후 127을 2진수로 변환하여 지수부를 채운다.
      - 5. 부동소수점의 값이 음수이면 비트부호 = 1, 양수이면 비트부호 = 0 을 할당한다.
      
      ![](./images/2021-12-03-00-44-37.png)

- 부동소수점의 유효 범위
  - 4byte ->  7자리까지 유효(그 이상은 짤림, 그러나 오류는 발생하지 않음)
  - 8byte ->  8자리까지 유효(그 이상은 짤림, 그러나 오류는 발생하지 않음)
